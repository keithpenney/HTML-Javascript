Javascript Language Notes

General:
--------
    Interpreted language.
    Case-sensitive.
    Lines should end with semi-colons; if they don't, Automatic Semi-Colon Insertion (ASI) occurs.
    Built for web as a complement to HTML and CSS.
    Comments are C-style // single line or /* multi-line */
    JavaScript is loaded on a page in the brower's JavaScript engine after the HTML and CSS.
    Each browser tab is its own "execution environment" (no tab-to-tab scripting)

Running JavaScript Files:
-------------------------
    JavaScript files (typically with extension .js) are interpreted by a JavaScript Runtime
    Environment (an executable file which takes the JavaScript file as input and dynamically
    generates and executes machine code).

    Example JavaScript Runtime Environments:
        Node.js
            node[.exe] [options] [script.js] [arguments]

Applying JavaScript to HTML:
----------------------------
    In-line HTML:
        <script>
          // JavaScript code goes here 
        </script>
    External JavaScript:
        <script src="myscript.js"></script>

    HTML can also take JavaScript as e.g. attribute values, but this is BAD practice.
        <button onclick="myButtonHandler()">A dynamic button</button>

Web Console:
------------
    Since JavaScript is an interpreted language, we can interact with a session 'live' (like 
    Python's console). To do this, we can open any script/html document in a browser and use the 
    "Web Console" or "JavaScript Console" listed under the developer tools.

    console.log()       Output to the console
    
    Similar to Python's 'print()', console.log() can accept nearly anything as an argument. Basic
    arguments include,
        console.log("Any ol' string");
        console.log(someObject);
        console.log("This object, " + someObject + " is now stringified.");

    It also accepts a special form of string enclosed by backticks (`) rather than single or double
    quotes which functions sort of like bash evaluation.  Within the backticks, anything enclosed
    in ${} will be evaluated before including in the string.
        var myName = "Keef";
        console.log("Hello, my name is " + myName); // One way to do it
        console.log(`Hello, my name is ${myName}`); // Alternate, using backticks and evaluation

Reserved Keywords:
------------------
    const               Declare a constant variable
    do                  Begin a do-while loop.
    false               Boolean false value.
    for                 Begin a for loop.
    function            Declare a function.
    in                  Used within a 'for...in' loop
    let                 Declare a variable local in scope.
    new                 Call a constructor function returning an object.
    of                  Used within a 'for...of' loop
    return              Return a value (or nothing) from a function.
    true                Boolean true value.
    typeof              Returns the type of a variable.  NOT a function! // typeof myVar;
    undefined           This is the value for a var that has been declared but not initialized/assigned.
    var                 Declare a variable (will overwrite any global variable).
    while               Begin a while loop.

Operators:
----------
    Arithmetic
    +, -, *, /, %       Addition, subtraction, multiplication, float division, modulo (remainder)
    +=, -=, *=, /=      Add-assign, subtract-assign, multiply-assign, divide-assign
    ++, --              Increment, decrement.  Can be pre-fix or post-fix w/ the typical results.

    Comparison
    ===                 Strict equality (e.g. a === b; is a exactly equal to b?)
    !==                 Inequality.
    >, <, >=, <=        Less than, greater than, less than or equal, greater than or equal

    Boolean
    &&, ||              Boolean AND and OR respectively.

    Ternary             Just like other C-type languages, JavaScript supports the ternary operator
    (TEST) ? T : F      Evaluates 'TEST'; returns T if TEST === true, F if TEST === false

Variables:
----------
    Variables are weakly typed (duck typing).  The type of a variable is inherited from its value.
    Variable names can include underscore "_", letters, dollar sign "$", or digit (cannot start 
    with digit). Variables are declared either with the "var" keyword or the "let" keyword with the
    difference being scoping (see below).

    // ---- Syntax Example ---- //
        var myVariable = someValue;
    // ---- End Example ---- //

    Methods and Properties:
    -----------------------
        The type of the variable determines the available properties and methods.

        Universal Properties:
            style

        Universal Methods:
            toString()
            valueOf()

    'let' vs. 'var':
    ----------------
        Two keywords can be used to declare variables with subtle but important differences in the
        resulting scope.

        Global Scope:
        -------------
            When defined in the global scope, 'var' creates a property on the global object 'this'
            or 'window', while 'let' does not.
                // --- Example --- //
                var x = 'hello';
                let y = 'again';
                console.log(this.x); // prints 'hello'
                console.log(this.y); // undefined!
                // --- End Example --- //

        Block Scope:
        ------------
            Variables defined with 'var' will redefine global scope variables when re-defined in
            block scope.  Variables defined with 'let' will define another temporary block-scope
            variable which will not overwrite the value of the global scope variable of the same
            name.
                // --- Example --- //
                function Test() {
                  var x = 1;
                  let y = 1;
                  {
                    var x = 2;      // Overwrites the value of global 'x'
                    let y = 2;      // Creates local-scope 'y' distinct from function-scope 'y'
                    console.log(x); // prints '2'
                    console.log(y); // prints '2'
                  }
                  console.log(x);   // prints '2' again
                  console.log(y);   // prints '1'
                }

                function mixedTest() {
                  var x = '1';
                  let y = '1';
                  {
                    let x = '2';    // Happily creates a new local-scope 'x'
                    var y = '2';    // ERROR! Redeclaration of 'y' not allowed!
                  }
                }
                // --- End Example --- //

        Temporal Dead Zone:
        -------------------
            This is a weird behavior caused by non-sequential parsing of the js file.  If a
            variable is referenced before being declared, typically its value is 'undefined'.
            But if that variable is later declared (in the same scope) with a 'let' keyword, the
            reference throws an error (ReferenceError) rather than producing the value 'undefined'.
            This non-sequential dependence can be very unintuitive, but if your scope blocks are
            not very large, this shouldn't be hard to debug.

            The space within a scope before a variable is declared with 'let' is referred to as
            the 'temporal dead zone' since any references to it will cause an error.

            // --- A subtle error example case --- //
            function test(){
              var foo = 33;
              if(foo) {
                let foo = (foo + 55);   // ReferenceError since the 'foo' in '(foo + 55)' refers to
              }                         // the local-scope 'foo' which is not yet defined (defined
            }                           // after the RHS is evaluated)
            // --- End Example --- //


    Strings:
    --------
        Single quotes '' or double quotes "" are both acceptable (as long as they match).
        Accepts escape sequences.  E.g.: \n, \t, \uXXXX (unicode codepoint)
        Strings can be concatenated with the '+' operator.  When using the '+' operator between a
        string and a number, it is implied that the number will be converted to a string (using 
        the 'tostring()' method).  This is bad form. Just be explicit about converting objects to
        the exact type you intend.
        Strings are compared using the boolean > and < operators.  Same results as C's strcmp()
        String literals and primitives have access to the same methods/properties as instances of
        the "String" class, but there are differences in how the string literal is interpreted at
        construction.

        Convert a string to a number with Number()

        String Object Methods:
            s.charAt(n)             // Return the character at index n.  str.charAt(n) -> str[n];
            s.indexOf(b)            // Return the starting index of substring 'b' within string 's'.
                                    // Returns -1 if 'b' is NOT contained within 's'.
            s.replace(from, to)     // Returns copy of 's' w/ substring 'from' replaced w/ string 'to'
            s.slice(nb, ne)         // Returns the slice of 's' from index 'nb' to index 'ne'.
                                    // If 'ne' not provided, assumes ne = s.length - 1
            s.search(regexp)        // Returns first index of substring in 's' matching regexp (else -1).
            s.split(sep [,lim])     // Returns array of substrings of 's' split by string 'sep'
                                    // (up to 'lim' if given)
            s.toUpperCase()         // Returns 's' with all characters in UPPERCASE
            s.toLowerCase()         // Returns 's' with all characters in lowercase
            s.trim()                // Returns 's' with whitespace trimmed from both ends.
            s.valueOf()             // Returns the string primitive value of 's'

        String Object Properties:
            s.length                // The number of chars in the 's' (not counting nul terminator)

    Arrays:
    -------
        Arrays can be of mixed type (like a C-style void *[])
        // ---- Syntax Example ---- //
        var myArray = [4, 220, 32.1, -7];
        var myOtherArray = ["Keef", 'hablas', 'meijor'];
        var anotherArray = ["Words", 42, ["sub", 3.14159, "array"], 0];     // nested/mixed

        Array Object Methods:
            a.join(ch)              // Returns a string of all elements of 'a' concatenated with
                                    // adjoining string 'ch'
            a.push(x)               // Appends item 'x' to the end of array 'a'. Returns resulting
                                    // index of 'x' in 'a'
            a.pop()                 // Removes and returns the last item in array 'a'.
            a.shift()               // Removes and returns the first item in array 'a'.
                                    // (i.e. backwards pop())
            a.unshift(x)            // Adds item 'x' to the beginning of array 'a', returns new 
                                    // array length (i.e. backwards push())

        Array Object Properties:
            a.length                // The number of elements in array 'a'

    Objects:
    --------
        JavaScript "objects" are like a cross between Python dicts and C structs.  The declaration
        syntax is similar to Python dicts, but the are not resolvable identifiers (i.e. literals
        or pre-defined variables) but are member names like a C struct.  Object item access looks
        just like member access or C struct dereference.

        // ---- Syntax Example ---- //
        var dog = {breed : "mutt", name : "Roy Blount"};
        console.log(dog.name);  // Fetch an object property like pointer dereference
        // --- End Example --- //

        See "Object Prototypes" below for a detailed discussion.

Functions:
----------
    Functions work pretty much as expected for a weakly typed language.
    One notable difference with Python is the lack of a notion of "args vs. kwargs". In JavaScript,
    any parameter can have a default value and can be defined in any order.

    When a function is called, arguments are assigned to parameters left-to-right. If a parameter
    did not receive a value, it takes on its default value if it has one.  If it does not have a
    value, it takes on the value 'undefined'

    // ---- Syntax Example ---- //
    function foo(arg1, arg2 = 99, arg3) {
      // Note that arg1 and arg3 have no default value but arg2 does.
      var bar = arg1 + arg1;    // Do stuff with arguments arg1 and arg2 (non-typed, of course)
      return bar;               // Return a value
    }
    // ----  End Example  ---- //

    Anonymous Functions:
    --------------------
        In JavaScript, anonymous functions are primarily used for event handlers.

        // ---- Example ---- //
        function() {
          console.log("I have no name!");
        }

        myButton.onclick = function() {
          alert("Thanks for clicking the button.");
        }

        function(arg1, arg2) {      // This is how to pass arguments to anonymous functions
            return arg1 + arg2;
        }
        // ----  End Example  ---- //

    Generator Function:
    -------------------
        A generator is a function that can be entered and re-entered, resuming execution at the
        point where it last exited.  A generator function returns a generator object, which has
        a 'next()' method.  Calling the 'next()' method on the generator the first time begins
        execution and halts at the first 'yield'.  Subsequent calls to the 'next()' method pick
        up execution at the last place the function exited and continue until the next 'yield.'

        An argument passed to 'next()' replaces the value yielded by the 'yield' statement where
        it last left off, and subsequent references to that variable use the new value (passed as
        the 'next()' argument).

        // ---- Syntax Example ---- //
        function* myFunc(arg1, arg2, arg3) {
            // stuff
        }
        // ----  End Example  ---- //

        // --- Example --- //
        function* myGen(n) {
            yield n;
            yield n + 10;
            yield n + 20;
            return n + 30;
        }

        var gen = myGen(5);
        console.log(gen.next());        // prints object { value: 5, done = false }
        console.log(gen.next().value);  // prints 15
        console.log(gen.next().value);  // prints 25
        console.log(gen.next());        // prints object { value: 35, done = true }
        console.log(gen.next());        // prints object { value: undefined, done = true }
        // --- End Example --- //

        See 'generators.js' for some useful generator examples.

    Arrow Functions:
    ----------------
        Arrow functions (named for their syntax) were created to solve a problem with object methods being able to
        properly refer to their parent object via the Java-style 'this' keyword.
        Normal functions automatically define their 'this' keyword when executed in a global context.
        Arrow functions don't do this, so their 'this' keyword refers to the enclosing execution context.
        // ---- Syntax Example ---- //
        (arg1, arg2, arg3) => {
          // statements
          return;                   // Optionally return a value
        }

        var myArrowFunc = () => { console.log("This is an arrow function!"); }

    Built-In Functions:
    -------------------
        isNaN(n)                    // Returns true if 'n' === NaN (not a number)

Flow Control:
-------------
    Conditionals:
    -------------
        The reserved keywords for boolean true and false are "true" and "false" (lowercase).
        The following values are evaluated as false:
            false, undefined, null, 0, NaN, '' (empty string)
        Any value that is not listed above will evaluate as true.

    If Statement:
    -------------
        // ---- Syntax Example ---- //
        if ( CONDITION ) {
            // Do stuff if CONDITION === true
        } else if ( CONDITION2 ) {
            // Do stuff if CONDITION2 === true
        } else {
            // Do stuff if neither condition is true
        }
        Recall that the ternary operator (see 'Operators' above) can replace simple If statements
        and save space.

    For Loop:
    ---------
        For loops can be written in three different ways.  The basic for loop follows the C/Java
        with only slight differences in what's allowed.  The basic for loop has the following
        syntax:
            for (INIT; COND; FINAL) { ...  };
                INIT (optional) is an expression that evaluates once before the loop begins.
                COND (optional) is an expression which is evaluated before every iteration through
                     the loop and returns a boolean value.  If omitted, it always returns true.
                FINAL (optional) is an expression evaluated at the end of each loop (before COND)
                     and is typically used to increment a value tested within COND.
                ...  is the expression(s) to execute on every loop.

        // ---- Basic For Loop ---- //
        for (var i = 0; i < 10; i++) {
            // do this until i >= 10
        }
        // --- End Example --- //

        An alternate for loop syntax allows for iterating over all properties/methods/indicies of
        an enumerable object.  The object could be an array, a class instance, a string, etc.
        The syntax is:
            for (KW FOO in ENUMERATOR) { ... };
                KW  (optional) is 'let', 'var', or 'const' depending on the declaration/use of
                    name FOO.
                FOO is the name of the variable to take on values from ENUMERATOR.  On each loop,
                    FOO will take on the value of another index of ENUMERATOR (be it a string, or
                    number).  Items of ENUMERATOR can then be access via bracket notation:
                    ENUMERATOR[FOO]
                ENUMERATOR is the enumerable object over which to loop.
                ... is the expression(s) to execute on every loop.

        // ---- Enumerator For Loop "for ... in" ---- //
        var myList = ["piggies", "kitties", "snakesss"];

        for (const index in myList) {
            console.log("I like " + myList[index]);
        }
        // --- End Example --- //

        Another alternate for loop syntax allows for iterating over an iterable object. In this
        case, instead of a variable taking on a value of a different index of the object on each
        loop, it actually takes on the value of each particular property/method/item of the object.
        The syntax is:
            for (KW FOO of ITERATOR) { ... };
                KW  (optional) is 'let', 'var', or 'const' depending on the declaration/use of
                    name FOO.
                FOO is the name of the variable to take on values from ITERATOR.  On each loop,
                    FOO will take on the value of another item within ITERATOR.
                ITERATOR is the enumerable object over which to loop.
                ... is the expression(s) to execute on every loop.

        // ---- Iterator For Loop: "for ... of" ---- //
        for (const item of myList) {
            console.log("I like " + item);
        }
        // --- End Example --- //

    Switch Statements:
    ------------------
        // ---- Syntax Example ---- //
        switch (EXPRESSION) {
          case VAL1:
            // run if EXPRESSION === VAL1
            break;
          case VAL2:
            // run if EXPRESSION === VAL2
            break;
          default:
            // run if EXPRESSION === some other value besides VAL1 or VAL2
            // default case doesn't need 'break'
        }

    While Loop:
    -----------
        Just like in C, the "while loop" checks the condition before running the code, the "do-while loop" checks the
        condition after running the code (for the first time).
        // ---- Syntax Example ---- //
        while (CONDITION) {
          // do stuff.  Make sure to iterate some value to prevent an infinite loop.
        }

    Do-While Loop:
    --------------
        // ---- Syntax Example ---- //
        do {
          // do stuff.  Again, make sure to iterate some value to prevent an infinite loop.
        } while (CONDITION);    // Note the semi-colon

Events:
-------
    JavaScript UI is generally written in an event-based paradigm.  An event is a signal emitted
    (typically by an object) when something has occurred.  We register event handlers to respond
    to events based on our intended design outcomes.  Events exists only within the particular
    browser session (are not system-wide). The exact way in which events are generated and handled
    is dependent on the particular event model which is determined by the runtime environment in
    which you're operating (i.e. Node.js).

    Event Listener:     A piece of code that waits for a particular event signal to arrive
    Event Handler:      A piece of code that is executed in response to an event signal

    There are several ways to make a function respond to an event.

    Object Properties:
    ------------------
        All objects which can respond to an event have a variety of properties which function as
        callables which can be overwritten by the application programmer.  A property such as
        'object.onclick' (as in the example below) can be assigned to a function (anonymous or
        named), and that function is called when the particular event is triggered.

        // --- Example --- //
        button.onclick = someFunction;      // Named function (note that we're not calling this
                                            // function, i.e. no trailing parentheses)
        button.onclick = function() {       // Anonymous function
            console.log("button clicked!");
        }
        // --- End Example --- //

        Example Objects and Properties:
        -------------------------------
            button                          // Where is this class defined?
                onclick                     // Respond to a button click
                ondblclick                  // Respond to a double click
                onmouseover                 // Respond to a mouse entering the button
                onmouseout                  // Respond to a mouse leaving the button
            window                          // Again, where dis?
                onkeypress                  // Respond to key press (down) (only printable keys)
                onkeydown                   // Respond to key press down (all keys)
                onkeyup                     // Respond to key release (up) (all keys)

    HTML Attributes (don't do this):
    --------------------------------
        The earliest method for registering an event handler was by adding an object attribute
        directly in the HTML whose value was the JavaScript code to run when the event fires.
        This method is strongly discouraged now since it mixes the visual representation (HTML)
        with the functional behavior (JavaScript) inextricably.

        // ---   Example   --- //
        <button onclick = "alert("You just clicked me!");">Click me</button>
        <button onclick = "myClickHandler();">Click me too</button>
        // --- End Example --- //

    Event Listeners:
    ----------------
        The newest method for registering event handlers is through an API introduced in the
        Document Object Model (DOM) Level 2 Events specification.  It includes two new methods
        inherited by nearly all objects.
            addEventListener(evt, handler)  // Associate event 'evt' with a listener/handler
            removeEventListener(evt, handler) // Remove association between 'evt' and 'handler'

        // ---   Example   --- //
        button = document.querySelector('button');  // Grab the first button from the HTML document
        button.addEventListener('click', myClickHandler);   // Register a named handler function
        button.addEventListener('click', function() {       // Register an anonymous handler
            console.log("I got clicked.");
            });
        // --- End Example --- //

        This method has a few benefits over the object properties method.
        1) Multiple listeners can be registered for the same event.
           Any other method would overwrite a previously registered handler/listener when a new
           one is registered.
        2) Unused handlers/listeners can be removed and garbage-collected when they are no longer
           needed.

        Example Events:
        ---------------
            Event reference: https://developer.mozilla.org/en-US/docs/Web/Events
            Focus Events:
                focus                   // An element has received focus
                blur                    // An element has lost focus
                focusin                 // An element is about to gain focus
                focusout                // An element is about to lose focus
            
            WebSocket Events:
                open                    // A WebSocket connection has been established
                message                 // A message is received through a WebSocket
                close                   // A WebSocket connection has been closed
                error                   // A connection has been closed with prejudice

            Keyboard Events:
                keypress                // Any printable key is pressed (continuously fired)
                keydown                 // Any key pressed (fired once)
                keyup                   // Any key released (fired once)

            Mouse Events:
                click                   // Any click (soon to be only primary) press + release
                auxclick                // Any non-primary button click press + release
                contextmenu             // The right button clicked (before context menu popup)
                dblclick                // A double-click occurred
                mouseenter              // The cursor has moved onto the element
                mouseleave              // The cursor has moved off the element
                mouseover               // = mouseenter + the element's children
                mouseout                // = mouseleave + the element's children

    Event Objects:
    --------------
        An event handler can have an optional argument.  When the function is called, an event
        object will be passed to the handler function as this argument.  An event object is an
        instance of a class which implements the DOM Event interface.  The Event interface has
        some standard properties but most event objects will have properties unique to the object
        itself.

        Event Interface:
        ----------------
            [properties]
            target      // A (read-only) reference to the target to which the event was dispatched
            type        // The name of the event (case-insensitive)
            eventPhase  // Indicates which phase of the event flow is being processed
            bubbles     // A boolean indicating whether the event bubbles up through the DOM

            [methods]
            preventDefault()    // Cancels the event if cancelable
            stopPropagation()   // Stops the propagation of events further along in the DOM

            This is a non-exhaustive list.  For more, visit this reference page.
            Full Event Class Reference: https://developer.mozilla.org/en-US/docs/Web/API/Event

        Example Event Interface: KeyboardEvent
        --------------------------------------
            [Properties]
            key         // A DOMString representing the key corresponding to the event
            code        // A DOMString with the code value of the physical key location
            altkey      // Boolean. True if Alt (Options on OSX) was held when event occurred
            ctrlkey     // Boolean. True if Ctrl was held when event occurred
            shiftkey    // Boolean. True if Shift was held when event occurred
            metakey     // Boolean. True if Windows key (Command key on OSX) held when occurred

            [Methods]
            getModifierState()  // Returns boolean indicating whether any modifier key was held
                                // when the event occurred.

            [Event Objects]
            keydown
            keyup
            keypress (obsolete! don't use)

        Preventing Default Behavior:
        ----------------------------
            Many events derived from HTML objects have default behavior that will occur unless
            prevented.  In order to implement our custom application, we often need to prevent
            this behavior.  An example is an HTML form object.  Typically when a form is submitted
            the data is sent unvalidated to the target server.  In order to block the submission
            upon entry of invalid data, we need to suppress the default behavior.  This is done
            with an Event interface method, Event.preventDefault().

            // ---   Example   --- //
            var form = document.querySelector('form');  // Get the form from some HTML document

            function dataIsValid() {
              // Do something here to validate form data
              if (...) {
                return true;
              } else {
                return false;
              }
            }

            function validateAndSubmit(evt) {
              if (!dataIsValid()) {
                evt.preventDefault();           // If data is invalid, prevent default submission
                alert("Data invalid!");
              }
            }

            form.addEventListener('submit', validateAndSubmit);
            // --- End Example --- //

        Event Capturing and Bubbling:
        -----------------------------
            As with most event-based environments, an event continues to propagate after it meets
            an event handler.  This means it can continue on to other event handlers registered on
            the same object or a parent/child object.  The order in which event handlers will be
            processed depends on the phase of the event object.

            Capturing Phase:
                The top-most parent object is first checked for handlers for the event, then the
                family tree is walked down to the bottom-most child object searching for handlers
                for a particular event.  By default all appropriately registered handlers will
                execute in the order in which they are encountered.

            Bubbling Phase:
                The bubbling phase also searches for event handlers but does it in the exact
                opposite order as the capturing phase (bottom-most child to top-most parent).

            In most modern browsers, all events are registered for the bubbling phase (i.e. they
            start at the bottom), but this can be configured per-event.

            If we want to prevent an event from bubbling/capturing further, we can stop it in an
            event handler with Event.stopPropagation()

Object Prototypes:
------------------
    JavaScript is a mostly-object-oriented language.  Objects can be created as object literals
    or as instances of a class/prototype. 

    Object Literals:
    ----------------
        We can define an object simply by declaring it with the following syntax.  The resulting
        item is known as an object literal.
        // ---   Example   --- //
        const myObject = {              // The 'const' keyword doesn't actually make this read-only
          name : 'Demo Object';
          coords : [100, 250];
          dims : [120, 40];
          getName: function() {
            return this.name;
          },                            // This comma is easy to forget
          getCoords: function() {
            return this.coords;
          },
          setName: function(name) {
            this.name = name;
          },
          setCoords: function(x, y) {
            this.coords = [x, y];
          }                             // Of course there's no comma after the last item
        }

        // Property access via dot notation
        console.log("object " + myObject.name + " is at (x = " + myObject.coords[0] + ", y = " \
                    + myObject.coords[1] + ")");

        // Property access via bracket notation
        console.log("object " + myObject['name'] + " is " + myObject['dims'][0] + " wide and " \
                    + myObject['dims'][1] + " high.");
        // --- End Example --- //

        We can also define an object literal using the constructor syntax (see below) and the
        default object constructor Object().  Of course this would not populate the object, so we
        would then need to add properties/methods to the object as needed, i.e:

        // ---   Example   --- //
            const myObject = new Object();
            myObject.name = "Ted";          // Adding using dot syntax
            myObject['color'] = "Blue";     // Adding using bracket syntax
        // --- End Example --- //

        Lastly, we can also create a new object based on an existing object (either a literal or
        an instance) using the Object.create() method (not supported on IE8 or earlier, btw). This
        is actually creating a second object using the first object as a prototype, which is
        distinct from creating two objects from the same constructor, but for many simple purposes
        it works in much the same way.

        // ---   Example   --- //
            const foo = { ... }             // Create some object
            const bar = Object.copy(myObject)   // Create another object based on myObject
            console.log(bar.__proto__)      // bar.__proto__ is a reference to foo.prototype
        // --- End Example --- //

    Constructors:
    -------------
        In JavaScript, a constructor serves as the class definition as well.  Syntactically, it's
        a function that doesn't return anything and can use the 'this' identifier to specify
        properties and methods of the resulting object.  When an object is to be instantiated from
        a constructor, the 'new' keyword is used.

        // ---   Example   --- //
        function Person(name, age = 40) {
          this.name = name;
          this.age = age;
          this.greeting = function() {
            return "hello, my name is " + this.name + " and I'm " + this.age + " years old.";
          };
        }

        let person1 = new Person("Keef", 31);
        let person2 = new Person("Cecee", 30);
        let person3 = new Person("Stokely", 0);

        for (let person of [person1, person2, person3]) {
          console.log(person.greeting());
        }
        // --- End Example --- //
        
        The constructor Property:
        -------------------------
            Every constructor function has a 'prototype' property whose value is an object
            containing a 'constructor' property which is a reference to the constructor function.
            So the 'constructor' property is actually a function, but it is NOT a method in that
            it is not dependent on any properties of a particular object.

            Therefore, if you don't have access to an object's constructor but you need to create
            another object of the same class, you can use:
                const newObject = new someObject.constructor(); // Note the 'new' keyword!

            And of course to use the function as a constructor, you must use the 'new' keyword
            (otherwise it will just call the function which by definitions retuns nothing).

            Fun fact: you can get the name of the constructor with the 'name' property of the
                      'constructor' property (i.e. foo.constructor.name).

    Prototypes and Inheritance:
    ---------------------------
        JavaScript implements inheritance through prototypes, which are a special object
        referenced by a parent object which contain all the methods/properties that are to be
        inherited by child objects.  Note! This means not all methods/properties are inherited
        like they are in Python.  Note also that there are no access permissions like C++.

        Since ECMAScript 2015, there is now a standard method to get a reference to the prototype
        of an object: Object.getPrototypeOf(obj)

        Before ECMAScript 2015, many browsers supported (and still do) a special property called
        "__proto__" which is a reference to the prototype object from which an object inherits.

        Accessing Inherited Methods/Properties:
        ---------------------------------------
            Note that in JavaScript, inherited methods/properties are NOT copied to the child
            object.  Instead, when a method is called (or a property is accessed), the runtime
            engine first checks to see if that method/property is defined in the object itself. If
            it is not, it walks up the inheritance tree to the next object and looks for it there.
            It continues this process all the way up the tree - if a property is not found, it
            returns undefined; if a method is not found, it throws TypeError.

        Note that it is rarely useful to add properties directly to the prototype, as these will
        end up being static (i.e. the same for all objects and descendents), which doesn't provide
        much utility (though it's certainly allowed).

        To add methods to a prototype, you simply use the 'prototype' property of the constructor
        function.

        // ---   Example   --- //
            function Car(make, model, year) {
              this.make = make;
              this.model = model;
              this.year = year;
              this.description = [make, model, year].join(' ');
            }

            Car.prototype.getDescription = function() {
              return this.description;
            }
        // --- End Example --- //

        Inheritance:
        ------------
            Note: the following describes the implementation of inheritance before ECMAScript 2015.
                  It is clunky and convoluted, but it was the only way to do it so it is common to
                  see in older (pre-2015) codebases.

            We can define a constructor (Constructor_B) which inherits from another constructor's
            prototype (Constructor_A.prototype). Any objects instantiated from Constructor_B will
            inherit all methods/properties defined on Constructor_A.prototype.

            To implement this, we use the 'call' method of the constructor from which we want to
            inherit (Constructor_A) within the inheriting constructor (Constructor_B).  The 'call'
            method always take the first argment 'this', which is a reference to the resulting
            object which will inherit from the constructor.  Thus, if a constructor takes no
            arguments, its 'call' method still takes the argument 'this', i.e.:
                Constructor_A.call(this); // within Constructor_B

            The 'call' method takes care of inheritance of all properties/methods defined within
            the constructor, but does not include any defined on the prototype.  To set up the
            prototype chain, we need to assign the prototype. Note that this must occur before
            defining any methods/properties of the prototype or they will be clobbered by this
            assignment.  I.e.
                Constructor_B.prototype = new Constructor_A();  // One way of doing it
                Constructor_B.prototype = Object.create(Constructor_A.prototype); // Another way

            Finally if we want to make use of the 'constructor' property, we need to reassign it
            since it was clobbered by the above 'prototype' assignment. I.e.
                Constructor_B.prototype.constructor = Constructor_B;    // One way of doing it
                Object.defineProperty(Constructor_B.prototype, 'constructor', { // Another super
                  value : Protagonist,                                  // verbose way of doing
                  enumerable : false,                                   // it.  Not sure if there
                  writable : true                                       // are benefits.
                  });

            // --- Continuing from example above --- //
                function UsedCar(make, model, year, mileage) {
                  Car.call(this, make, model, year);  // Note the 'call' method and 'this' keyword
                  this.mileage = mileage;             // A property not inherited from Car
                }

                UsedCar.prototype = new Car();          // Set up the prototype chain
                UsedCar.prototype.constructor = UsedCar;// Re-establish the constructor
            // --- End Example --- //

Classes and ECMAScript 2015:
----------------------------
    ECMAScript 2015 defines a new syntax which makes JavaScript objects and inheritance clearer
    using conventions borrowed from C++/Java.

    The 'class' Keyword:
    --------------------
        ECMAScript 2015 introduces the keyword 'class' which is used to define an object prototype
        complete with its constructor, properties, and methods all in one place, very much like
        Java/C++.

        // ---   Example   --- //
        class Person {                                  // Class definition
          constructor(name, age, height, interests) {   // Constructor definition
            this.name = name;                           // Properties defined using 'this' as
            this.age = age;                             // before
            this.height = height;
            this.interests = interests;
          }                                             // Note! Constructor doesn't require a ';'

          greeting() {                                  // Method definition
            console.log("Hello, I'm " + this.name);     // Still have access to 'this' reference
          };
        }                                               // Also doesn't require a ';'

        // --- End Example --- //

    Inheritance:
    ------------
        Inheritance using the ECMAScript 2015 syntax is greatly simplified and clarified.  It
        introduces the keyword 'extends' to indicate that the class we're defining inherits from
        another.  The 'super()' method is also introduced which calls the constructor of the parent
        class.

        // ---   Example   --- //
        class Musician extends Person {
          constructor(name, age, height, instruments) {
            super(name, age, height, interests = ['music']);

            this.instruments = instruments;
          }
        // --- End Example --- //

    Getters and Setters:
    --------------------
        ECMAScript 2015 also introduced the keywords 'get' and 'set' to provide a nifty (albeit
        sneaky) way to access properties safer and more elegantly.  And as an extra bonus, the
        public syntax is unchanged, so people won't even know what's going on in the 'back end'.

        // ---   Example   --- //
        class SneakyFish {
          constructor(name, weight) {
            this.name = name;
            this._weight = weight;      // Here we mangle the name 'weight' so it doesn't get
          }                             // clobbered by the getters/setters
            
          get weight() {
            return this._weight;        // We won't modify the getter in this example
          }                             // Apparently this don't need a ';'

          set weight(newWeight) {
            newWeight = Number(newWeight);  // We'll sanitize the input a little
            this._weight = Math.abs(newWeight); // Can't have a negative weight, can we?
          }                             // This neither...
        }

        let martin = new SneakyFish("Martin", 5);
        console.log(`${martin.name} weighs ${martin.weight}lbs.`);

        martin.weight = "-25";          // This input should be sanitized.
        console.log(`Ol' ${martin.name} got fat and now weighs ${martin.weight}lbs!`);
        // --- End Example --- //

User Interface:
---------------
    // ---- Examples ---- //
    window.alert(msg);                  // a pop-up windows with a message 'msg' and an 'ok' button
    var response = window.prompt(msg);  // a window with an input field showing 'msg' and asking for
                                        // user input
    
Browser APIs:
-------------
    Document Object Model (DOM) API:    Enables dynamic manipulation of HTML elements.
        document.querySelector('sel')   // Returns a reference to the first object matching CSS
                                        // selector 'sel'
        document.querySelectorAll('sel') // Returns a list of references for all objects matching
                                        // CSS selector 'sel'

    Geolocation API:                    Enables discovery of user location and GPS.
    Canvas API:                         2D graphics and animation
    WebGL API:                          3D graphics and animation
    HTMLMediaElement API:               Enables playing audio/video and interfacing with cameras/mics.

    Third-Party APIs:
        Google Maps API:                    Embed Google Maps in your page; map routes, etc.
        Instagram, Twitter, etc.            All this bullshit.

