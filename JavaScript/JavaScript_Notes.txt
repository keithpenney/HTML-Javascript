Javascript Language Notes

General:
--------
    Interpreted language.
    Case-sensitive.
    Lines should end with semi-colons; if they don't, Automatic Semi-Colon Insertion (ASI) occurs.
    Built for web as a complement to HTML and CSS.
    Comments are C-style // single line or /* multi-line */
    JavaScript is loaded on a page in the brower's JavaScript engine after the HTML and CSS.
    Each browser tab is its own "execution environment" (no tab-to-tab scripting)

Applying JavaScript to HTML:
----------------------------
    In-line HTML:
        <script>
          // JavaScript code goes here 
        </script>
    External JavaScript:
        <script src="myscript.js"></script>

    HTML can also take JavaScript as e.g. attribute values, but this is BAD practice.
        <button onclick="myButtonHandler()">A dynamic button</button>

Web Console:
------------
    Since JavaScript is an interpreted language, we can interact with a session 'live' (like 
    Python's console). To do this, we can open any script/html document in a browser and use the 
    "Web Console" or "JavaScript Console" listed under the developer tools.

    console.log()       Output to the console

Reserved Keywords:
------------------
    const               Declare a constant variable
    false               Boolean false value.
    function            Declare a function.
    let                 Declare a variable local in scope.
    return              Return a value (or nothing) from a function.
    true                Boolean true value.
    typeof              Returns the type of a variable.  NOT a function! // typeof myVar;
    undefined           This is the value for a var that has been declared but not initialized/assigned.
    var                 Declare a variable (will overwrite any global variable).

Operators:
----------
    Arithmetic
    +, -, *, /, %       Addition, subtraction, multiplication, float division, modulo (remainder)
    +=, -=, *=, /=      Add-assign, subtract-assign, multiply-assign, divide-assign
    ++, --              Increment, decrement.  Can be pre-fix or post-fix w/ the typical results.

    Comparison
    ===                 Strict equality (e.g. a === b; is a exactly equal to b?)
    !==                 Inequality.
    >, <, >=, <=        Less than, greater than, less than or equal, greater than or equal

    Boolean
    &&, ||              Boolean AND and OR respectively.

    Ternary             Just like other C-type languages, JavaScript supports the ternary operator
    (TEST) ? T : F      Evaluates 'TEST'; returns T if TEST === true, F if TEST === false

Variables:
----------
    Variables are weakly typed (duck typing).  The type of a variable is inherited from its value.
    Variable names can include underscore "_", letters, dollar sign "$", or digit (cannot start 
    with digit). Variables are declared either with the "var" keyword or the "let" keyword with the
    difference being scoping (see below).

    // ---- Syntax Example ---- //
        var myVariable = someValue;
    // ---- End Example ---- //

    Methods and Properties:
    -----------------------
        The type of the variable determines the available properties and methods.

        Universal Properties:
            style

        Universal Methods:
            toString()
            valueOf()

    'let' vs. 'var':
    ----------------
        Two keywords can be used to declare variables with subtle but important differences in the
        resulting scope.

        Global Scope:
        -------------
            When defined in the global scope, 'var' creates a property on the global object 'this'
            or 'window', while 'let' does not.
                // --- Example --- //
                var x = 'hello';
                let y = 'again';
                console.log(this.x); // prints 'hello'
                console.log(this.y); // undefined!
                // --- End Example --- //

        Block Scope:
        ------------
            Variables defined with 'var' will redefine global scope variables when re-defined in
            block scope.  Variables defined with 'let' will define another temporary block-scope
            variable which will not overwrite the value of the global scope variable of the same
            name.
                // --- Example --- //
                function Test() {
                  var x = 1;
                  let y = 1;
                  {
                    var x = 2;      // Overwrites the value of global 'x'
                    let y = 2;      // Creates local-scope 'y' distinct from function-scope 'y'
                    console.log(x); // prints '2'
                    console.log(y); // prints '2'
                  }
                  console.log(x);   // prints '2' again
                  console.log(y);   // prints '1'
                }

                function mixedTest() {
                  var x = '1';
                  let y = '1';
                  {
                    let x = '2';    // Happily creates a new local-scope 'x'
                    var y = '2';    // ERROR! Redeclaration of 'y' not allowed!
                  }
                }
                // --- End Example --- //

        Temporal Dead Zone:
        -------------------
            This is a weird behavior caused by non-sequential parsing of the js file.  If a
            variable is referenced before being declared, typically its value is 'undefined'.
            But if that variable is later declared (in the same scope) with a 'let' keyword, the
            reference throws an error (ReferenceError) rather than producing the value 'undefined'.
            This non-sequential dependence can be very unintuitive, but if your scope blocks are
            not very large, this shouldn't be hard to debug.

            The space within a scope before a variable is declared with 'let' is referred to as
            the 'temporal dead zone' since any references to it will cause an error.

            // --- A subtle error example case --- //
            function test(){
              var foo = 33;
              if(foo) {
                let foo = (foo + 55);   // ReferenceError since the 'foo' in '(foo + 55)' refers to
              }                         // the local-scope 'foo' which is not yet defined (defined
            }                           // after the RHS is evaluated)
            // --- End Example --- //


    Strings:
    --------
        Single quotes '' or double quotes "" are both acceptable (as long as they match).
        Accepts escape sequences.  E.g.: \n, \t, \uXXXX (unicode codepoint)
        Strings can be concatenated with the '+' operator.  When using the '+' operator between a
        string and a number, it is implied that the number will be converted to a string (using 
        the 'tostring()' method).  This is bad form. Just be explicit about converting objects to
        the exact type you intend.
        Strings are compared using the boolean > and < operators.  Same results as C's strcmp()
        String literals and primitives have access to the same methods/properties as instances of
        the "String" class, but there are differences in how the string literal is interpreted at
        construction.

        Convert a string to a number with Number()

        String Object Methods:
            s.charAt(n)             // Return the character at index n.  str.charAt(n) -> str[n];
            s.indexOf(b)            // Return the starting index of substring 'b' within string 's'.
                                    // Returns -1 if 'b' is NOT contained within 's'.
            s.replace(from, to)     // Returns copy of 's' w/ substring 'from' replaced w/ string 'to'
            s.slice(nb, ne)         // Returns the slice of 's' from index 'nb' to index 'ne'.
                                    // If 'ne' not provided, assumes ne = s.length - 1
            s.search(regexp)        // Returns first index of substring in 's' matching regexp (else -1).
            s.split(sep [,lim])     // Returns array of substrings of 's' split by string 'sep'
                                    // (up to 'lim' if given)
            s.toUpperCase()         // Returns 's' with all characters in UPPERCASE
            s.toLowerCase()         // Returns 's' with all characters in lowercase
            s.trim()                // Returns 's' with whitespace trimmed from both ends.
            s.valueOf()             // Returns the string primitive value of 's'

        String Object Properties:
            s.length                // The number of chars in the 's' (not counting nul terminator)

    Arrays:
    -------
        Arrays can be of mixed type (like a C-style void *[])
        // ---- Syntax Example ---- //
        var myArray = [4, 220, 32.1, -7];
        var myOtherArray = ["Keef", 'hablas', 'meijor'];
        var anotherArray = ["Words", 42, ["sub", 3.14159, "array"], 0];     // nested/mixed

        Array Object Methods:
            a.join(ch)              // Returns a string of all elements of 'a' concatenated with
                                    // adjoining string 'ch'
            a.push(x)               // Appends item 'x' to the end of array 'a'. Returns resulting
                                    // index of 'x' in 'a'
            a.pop()                 // Removes and returns the last item in array 'a'.
            a.shift()               // Removes and returns the first item in array 'a'.
                                    // (i.e. backwards pop())
            a.unshift(x)            // Adds item 'x' to the beginning of array 'a', returns new 
                                    // array length (i.e. backwards push())

        Array Object Properties:
            a.length                // The number of elements in array 'a'

    Objects:
    --------
        JavaScript "objects" are like a cross between Python dicts and C structs.  The declaration
        syntax is similar to Python dicts, but the are not resolvable identifiers (i.e. literals
        or pre-defined variables) but are member names like a C struct.  Object item access looks
        just like member access or C struct dereference.

        // ---- Syntax Example ---- //
        var dog = {breed : "mutt", name : "Roy Blount"};
        console.log(dog.name);  // Fetch an object property like pointer dereference

Functions:
----------
    Functions work pretty much as expected for a weakly typed language.
    One notable difference with Python is the lack of a notion of "args vs. kwargs". In JavaScript,
    any parameter can have a default value and can be defined in any order.

    When a function is called, arguments are assigned to parameters left-to-right. If a parameter
    did not receive a value, it takes on its default value if it has one.  If it does not have a
    value, it takes on the value 'undefined'

    // ---- Syntax Example ---- //
    function foo(arg1, arg2 = 99, arg3) {
      // Note that arg1 and arg3 have no default value but arg2 does.
      var bar = arg1 + arg1;    // Do stuff with arguments arg1 and arg2 (non-typed, of course)
      return bar;               // Return a value
    }
    // ----  End Example  ---- //

    Anonymous Functions:
    --------------------
        In JavaScript, anonymous functions are primarily used for event handlers.

        // ---- Example ---- //
        function() {
          console.log("I have no name!");
        }

        myButton.onclick = function() {
          alert("Thanks for clicking the button.");
        }
        // ----  End Example  ---- //

    Generator Function:
    -------------------
        A generator is a function that can be entered and re-entered, resuming execution at the
        point where it last exited.  A generator function returns a generator object, which has
        a 'next()' method.  Calling the 'next()' method on the generator the first time begins
        execution and halts at the first 'yield'.  Subsequent calls to the 'next()' method pick
        up execution at the last place the function exited and continue until the next 'yield.'

        An argument passed to 'next()' replaces the value yielded by the 'yield' statement where
        it last left off, and subsequent references to that variable use the new value (passed as
        the 'next()' argument).

        // ---- Syntax Example ---- //
        function* myFunc(arg1, arg2, arg3) {
            // stuff
        }
        // ----  End Example  ---- //

        // --- Example --- //
        function* myGen(n) {
            yield n;
            yield n + 10;
            yield n + 20;
            return n + 30;
        }

        var gen = myGen(5);
        console.log(gen.next());        // prints object { value: 5, done = false }
        console.log(gen.next().value);  // prints 15
        console.log(gen.next().value);  // prints 25
        console.log(gen.next());        // prints object { value: 35, done = true }
        console.log(gen.next());        // prints object { value: undefined, done = true }
        // --- End Example --- //

        See 'generators.js' for some useful generator examples.

    Arrow Functions:
    ----------------
        Arrow functions (named for their syntax) were created to solve a problem with object methods being able to
        properly refer to their parent object via the Java-style 'this' keyword.
        Normal functions automatically define their 'this' keyword when executed in a global context.
        Arrow functions don't do this, so their 'this' keyword refers to the enclosing execution context.
        // ---- Syntax Example ---- //
        (arg1, arg2, arg3) => {
          // statements
          return;                   // Optionally return a value
        }

        var myArrowFunc = () => { console.log("This is an arrow function!"); }

    Built-In Functions:
    -------------------
        isNaN(n)                    // Returns true if 'n' === NaN (not a number)

Flow Control:
-------------
    Conditionals:
    -------------
        The reserved keywords for boolean true and false are "true" and "false" (lowercase).
        The following values are evaluated as false:
            false, undefined, null, 0, NaN, '' (empty string)
        Any value that is not listed above will evaluate as true.

    If Statement:
    -------------
        // ---- Syntax Example ---- //
        if ( CONDITION ) {
            // Do stuff if CONDITION === true
        } else if ( CONDITION2 ) {
            // Do stuff if CONDITION2 === true
        } else {
            // Do stuff if neither condition is true
        }
        Recall that the ternary operator (see 'Operators' above) can replace simple If statements and save space.

    For Loop:
    ---------
        // ---- Syntax Example ---- //
        for (var i = 0; i < 10; i++) {
            // do this until i >= 10
        }

    Switch Statements:
    ------------------
        // ---- Syntax Example ---- //
        switch (EXPRESSION) {
          case VAL1:
            // run if EXPRESSION === VAL1
            break;
          case VAL2:
            // run if EXPRESSION === VAL2
            break;
          default:
            // run if EXPRESSION === some other value besides VAL1 or VAL2
            // default case doesn't need 'break'
        }

    While Loop:
    -----------
        Just like in C, the "while loop" checks the condition before running the code, the "do-while loop" checks the
        condition after running the code (for the first time).
        // ---- Syntax Example ---- //
        while (CONDITION) {
          // do stuff.  Make sure to iterate some value to prevent an infinite loop.
        }

    Do-While Loop:
    --------------
        // ---- Syntax Example ---- //
        do {
          // do stuff.  Again, make sure to iterate some value to prevent an infinite loop.
        } while (CONDITION);    // Note the semi-colon

Events:
-------
    JavaScript UI is generally written in an event-based paradigm.  An event is a signal emitted
    (typically by an object) when something has occurred.  We register event handlers to respond
    to events based on our intended design outcomes.  Events exists only within the particular
    browser session (are not system-wide).

    Event Listener:     A piece of code that waits for a particular event signal to arrive
    Event Handler:      A piece of code that is executed in response to an event signal

    There are several ways to make a function respond to an event.
    // ---- Example ---- //
    button.onclick = someFunction();
    button.addEventListener('click', someFunction);

User Interface:
---------------
    // ---- Examples ---- //
    window.alert(msg);                  // a pop-up windows with a message 'msg' and an 'ok' button
    var response = window.prompt(msg);  // a window with an input field showing 'msg' and asking for user input
    
Browser APIs:
-------------
    Document Object Model (DOM) API:    Enables dynamic manipulation of HTML elements.
        document.querySelector('sel')   Returns a reference to the first object matching CSS selector 'sel'
        document.querySelectorAll('sel') Returns a list of references for all objects matching CSS selector 'sel'

    Geolocation API:                    Enables discovery of user location and GPS.
    Canvas API:                         2D graphics and animation
    WebGL API:                          3D graphics and animation
    HTMLMediaElement API:               Enables playing audio/video and interfacing with cameras/mics.

    Third-Party APIs:
        Google Maps API:                    Embed Google Maps in your page; map routes, etc.
        Instagram, Twitter, etc.            All this bullshit.

